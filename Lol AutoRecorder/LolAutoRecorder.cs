using Lol_AutoRecorder.Exceptions;
using Lol_AutoRecorder.Processors;
using LolAutoRecorder.Model;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;
using Microsoft.WindowsAPICodePack.Dialogs;
using System.ComponentModel;
using Ninject.Extensions.Logging;
using Lol_AutoRecorder.Constants;
using Lol_AutoRecorder.Interfaces;
using Lol_AutoRecorder.Wrappers;
using LolAutoRecorder.CommonLibrary.Interfaces;
using LolAutoRecorder.CommonLibrary.Enums;
using LolAutoRecorder.CommonLibrary.Exceptions;

namespace Lol_AutoRecorder
{
    public partial class LolAutoRecorder : Form
    {
        private const int DefaultReplaySpeed = 1;
        private const int DefaultFramesPerSecond = 60;
        private const string InitialProgressBarText = "0";
        private const string CompleteProgressBarText = "100";
        private const string LeagueClientProcessNameText = "League of Legends";
        private const string WaitingForInputText = "Waiting for user to start recording...";
        private const string LauncherPreparingText = "Preparing client to launch...";
        private const string NoReplaysText = "No replay playbacks in provided attached JSON file.";
        private const string LaunchingText = "Launching the replay...";
        private const string CompletedText = "Completed!";
        private const string ProvideSavePathText = "Please provide the path to save recordings.";
        private const string ClientAlreadyRunningText = "Another LeagueOfLegends process is already running. Do you want to terminate it?";
        private const string WarningText = "Warning";
        private const string ErrorText = "Error";
        private const string CancellingText = "Cancelling...";
        private const string ExecutableFilesFilterText = "Exe files (*.exe)|*.exe";
        private const string ExecutableFilesText = "Choose LeagueClient executable file";
        private const string RoflFilesFilterText = "ROFL files (*.rofl)|*.rofl";
        private const string RoflFilesText = "Choose ROFL file";
        private const string JsonFilesFilterText = "JSON files (*.json)|*.json";
        private const string JsonFilesText = "Choose metadata JSON file (generated by LoL Recorder Website)";
        private const string CancelText = "Cancel";

        private readonly IReplayRepository _replayRepository;
        private readonly IPressKeySimulator _pressKeySimulator;
        private readonly IParticipantIdToInitializerMapper _participantIdToInitializerMapper;
        private readonly IPlayerIdProvider _playerIdProvider;
        private readonly IReplayPlaybackProvider _replayPlaybackProvider;
        private readonly ILeagueClientLauncher _leagueClientLauncher;
        private readonly IUnprocessedFilesMonitor _unprocessedFilesMonitor;
        private readonly IRecordingProvider _recordingProvider;
        private readonly IProgressBarOperator _progressBarOperator;
        private readonly IRecordingCancellationManager _recordingCancellationManager;
        private readonly IScreenModeOperator _screenModeOperator;
        private readonly IStringToScreenModeMapper _stringToScreenModeMapper;
        private readonly ILogger _logger;

        private bool CloseLauncher { get; set; } = true;

        public LolAutoRecorder(
            IReplayRepository replayRepository,
            IPressKeySimulator pressKeySimulator,
            IParticipantIdToInitializerMapper participantIdToInitializerMapper,
            IPlayerIdProvider playerIdProvider,
            IReplayPlaybackProvider replayPlaybackProvider,
            ILeagueClientLauncher leagueClientLauncher,
            IUnprocessedFilesMonitor unprocessedFilesMonitor,
            IRecordingProvider recordingProvider,
            IProgressBarOperator progressBarOperator,
            IRecordingCancellationManager recordingCancellationManager,
            IScreenModeOperator screenModeOperator,
            IStringToScreenModeMapper stringToScreenModeMapper,
            ILogger logger) : this()
        {
            _replayRepository = replayRepository ?? throw new ArgumentNullException(nameof(replayRepository));
            _pressKeySimulator = pressKeySimulator ?? throw new ArgumentNullException(nameof(pressKeySimulator));
            _participantIdToInitializerMapper = participantIdToInitializerMapper ?? throw new ArgumentNullException(nameof(participantIdToInitializerMapper));
            _playerIdProvider = playerIdProvider ?? throw new ArgumentNullException(nameof(playerIdProvider));
            _replayPlaybackProvider = replayPlaybackProvider ?? throw new ArgumentNullException(nameof(replayPlaybackProvider));
            _leagueClientLauncher = leagueClientLauncher ?? throw new ArgumentNullException(nameof(leagueClientLauncher));
            _unprocessedFilesMonitor = unprocessedFilesMonitor ?? throw new ArgumentNullException(nameof(unprocessedFilesMonitor));
            _recordingProvider = recordingProvider ?? throw new ArgumentNullException(nameof(recordingProvider));
            _progressBarOperator = progressBarOperator ?? throw new ArgumentNullException(nameof(progressBarOperator));
            _recordingCancellationManager = recordingCancellationManager ?? throw new ArgumentNullException(nameof(recordingCancellationManager));
            _screenModeOperator = screenModeOperator ?? throw new ArgumentNullException(nameof(screenModeOperator));
            _stringToScreenModeMapper = stringToScreenModeMapper ?? throw new ArgumentNullException(nameof(stringToScreenModeMapper));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        public LolAutoRecorder()
        {
            InitializeComponent();
            LoadDefaultPaths();
            ConfigureFirstRun();

            //todo: manage on prod
            ServicePointManager.ServerCertificateValidationCallback += (sender, certificate, chain, sslPolicyErrors) => true;
        }

        private void LoadDefaultPaths()
        {
            //TODO: refactor (load from configuration)
            _textBoxLeagueClientDirectoryPath.Text = LolReplay.LeagueOfLegendsDirectoryPath;
            _textBoxClientExecutableName.Text = LolReplay.LeagueOfLegendsExecutableName;
            _textBoxRoflFilePath.Text = LolReplay.RoflPath;
            _textBoxRecordingMetadataPath.Text = LolReplay.ReplayInfoPath;
            _textBoxRecordingSavePath.Text = LolReplay.RecordingSavePath;
        }

        private void ConfigureFirstRun()
        {
            _buttonCancel.Enabled = false;
            _comboBoxScreenMode.SelectedIndex = 0;
        }

        //Record button
        private async void _buttonRecord_Click(object sender, EventArgs e)
        {
            _logger.Info(Info.NewProcessStartInfo);
            _logger.Info($"League of Legends folder: {_textBoxLeagueClientDirectoryPath.Text}.");
            _logger.Info($"League of Legends executable name: {_textBoxClientExecutableName.Text} ");

            CloseLauncher = true;
            _buttonRecord.Enabled = false;
            _buttonCancel.Enabled = true;
            _comboBoxScreenMode.Enabled = false;
            LockOrUnlockTextBoxInputs(isReadOnly: true);
            CancellationToken cancelToken = _recordingCancellationManager.Generate();

            await Task.Factory.StartNew(async () =>
            {
                try
                {
                    Invoke(new Action(() =>
                    {
                        _labelAdditionalInfo.Text = string.Empty;
                        _circularProgressBar1.Visible = false;
                        _labelRecordingStatusInfo.Text = LauncherPreparingText;
                        _labelAdditionalInfo.Text = string.Empty;
                    }));

                    _logger.Info($"Getting information about replay playbacks from selected JSON file : {_textBoxRecordingMetadataPath.Text}");
                    CheckForExecutionCancelRequest(cancelToken);
                    List<ReplayPlayback> replayPlaybacks = await _replayPlaybackProvider.ProvideAsync(_textBoxRecordingMetadataPath.Text);
                    if (replayPlaybacks.Count == 0)
                    {
                        _logger.Warn($"No replay playbacks in provided attached JSON file: {_textBoxRecordingMetadataPath.Text}. Stopping the process.");
                        MessageBox.Show(NoReplaysText);
                        return;
                    }

                    if (string.IsNullOrEmpty(_textBoxRecordingSavePath.Text))
                    {
                        _logger.Warn(Info.ProvideSavePathInfo);
                        MessageBox.Show(ProvideSavePathText);
                        return;
                    }
                    _logger.Info($"Selected recording save path: {_textBoxRecordingSavePath.Text}");

                    _logger.Info($"Launching the selected ROFL file: {_textBoxRoflFilePath.Text} ");
                    CheckForExecutionCancelRequest(cancelToken);
                    if (IsLeagueProcessAlreadyRunning())
                    {
                        _logger.Info(Info.AntoherClientExecutingInfo);
                        DialogResult dialogResult = MessageBox.Show(ClientAlreadyRunningText, WarningText, MessageBoxButtons.YesNo);
                        if (dialogResult == DialogResult.No)
                        {
                            _logger.Info(Info.ProcessAbortInfo);
                            CloseLauncher = false;
                            return;
                        }
                        _logger.Info(Info.ClientProcessAbortInfo);
                        TerminateLeagueProcessIfRunning();
                    }
                    await _leagueClientLauncher.RunAsync(_textBoxLeagueClientDirectoryPath.Text, _textBoxClientExecutableName.Text, _textBoxRoflFilePath.Text);
                    Invoke(new Action(() => _labelRecordingStatusInfo.Text = LaunchingText));

                    _logger.Info(Info.WaitingForClientToStartInfo);
                    ReplayRecording replayRecording = await _replayRepository.GetReplayRecordingAsync();
                    _logger.Info(Info.LeagueClientStaredInfo);
                    Invoke(new Action(() =>
                     {
                         _labelRecordingStatusInfo.Text = $"Recording... (0 / {replayPlaybacks.Count})";
                         _circularProgressBar1.Text = InitialProgressBarText;
                     }));

                    _logger.Info(Info.DeletingTemporaryFilesInfo);
                    CheckForExecutionCancelRequest(cancelToken);
                    await _unprocessedFilesMonitor.DeleteUnprocessedFilesAsync(_textBoxRecordingSavePath.Text);

                    int totalRecordingLength = replayPlaybacks.Sum(replay => replay.Length);
                    _logger.Info($"Starting Recording processing | Number of recordings: {replayPlaybacks.Count}");
                    foreach (var replayPlaybackInfo in replayPlaybacks.Select((replayPlayback, i) => (replayPlayback, i)))
                    {
                        var recoringInfoText = $"Recording ({replayPlaybackInfo.i + 1} / {replayPlaybacks.Count})";
                        _logger.Info(recoringInfoText);
                        Invoke(new Action(() => _labelRecordingStatusInfo.Text = recoringInfoText));

                        await _replayRepository.RecordAsync(new Recording { IsRecording = false });

                        CheckForExecutionCancelRequest(cancelToken);
                        string selectedItem = string.Empty;
                        Invoke(new Action(() => selectedItem = _comboBoxScreenMode.SelectedItem.ToString()));
                        await _screenModeOperator.UpdateScreenMode(_stringToScreenModeMapper.Map(selectedItem));

                        _logger.Info(Info.GettingSummonerFocusInfo);
                        CheckForExecutionCancelRequest(cancelToken);
                        Initializer initializer = Initializer.Unknown;
                        try
                        {
                            PlayerIdProviderResult playerIdResult = _playerIdProvider.Provide(_textBoxLeagueClientDirectoryPath.Text, replayPlaybackInfo.replayPlayback.ChampionName);
                            initializer = _participantIdToInitializerMapper.Map(playerIdResult);
                            _logger.Info($"Summoner to focus on chosen: ({replayPlaybackInfo.replayPlayback.ChampionName}) - key: {(int)initializer}");
                        }
                        catch (PlayerIdProviderException)
                        {
                            var championInitializerErrorText = $"Champion: {replayPlaybackInfo.replayPlayback.ChampionName} cannot be mapped to id for current data provided. Using default camera instead.";
                            _logger.Warn(championInitializerErrorText);
                            Invoke(new Action(() => _labelAdditionalInfo.Text = championInitializerErrorText));
                        }

                        CheckForExecutionCancelRequest(cancelToken);
                        Recording recording = _recordingProvider.Provide(replayPlaybackInfo.replayPlayback, DefaultReplaySpeed, DefaultFramesPerSecond, _textBoxRecordingSavePath.Text);
                        var record = await _replayRepository.RecordAsync(recording);
                        if (record == null) throw new RestRepositoryException(Error.IncorrecServerDataError);

                        if (initializer != Initializer.Unknown)
                        {
                            _logger.Info(Info.FocusingOnChampionInfo);
                            await _pressKeySimulator.SendKeystrokeAsync(initializer);
                        }

                        await _progressBarOperator.Update(replayPlaybackInfo.replayPlayback.Length, totalRecordingLength, this, _circularProgressBar1, _labelRecordingStatusInfo, cancelToken);

                        _logger.Info(Info.WaitingForUnsavedRecordingsInfo);
                        CheckForExecutionCancelRequest(cancelToken);
                        Invoke(new Action(() => _labelRecordingStatusInfo.Text = $"Checking for temporary files... ({replayPlaybackInfo.i + 1} / {replayPlaybacks.Count})"));
                        bool canProceed = await _unprocessedFilesMonitor.CheckForUnprocessedFilesAsync(_textBoxRecordingSavePath.Text);
                        if (!canProceed)
                        {
                            var savingRecordingErrorText = $"There was a problem on saving recording: {replayPlaybackInfo.i + 1}. Continue?";
                            _logger.Error(savingRecordingErrorText);
                            if (MessageBox.Show(savingRecordingErrorText, ErrorText, MessageBoxButtons.YesNo) == DialogResult.No) return;
                        }
                    }

                    _logger.Info(Info.RecordingCompleteInfo);
                    Invoke(new Action(() =>
                    {
                        _circularProgressBar1.Text = CompleteProgressBarText;
                        _labelRecordingStatusInfo.Text = CompletedText;
                    }));
                }
                catch (ReplayPlaybackProviderException)
                {
                    _logger.Error(Error.InvalidMetadataFileError);
                    MessageBox.Show(Error.InvalidMetadataFileError);
                }
                catch (LeagueClientLauncherException)
                {
                    _logger.Error(Error.LaunchingReplayError);
                    MessageBox.Show(Error.LaunchingReplayError);
                }
                catch (UnprocessedFilesMonitorException)
                {
                    _logger.Error(Error.CriticalError);
                    MessageBox.Show(Error.CriticalError);
                }
                catch (RecordingProviderException)
                {
                    _logger.Error(Error.CreateRecordingError);
                    MessageBox.Show(Error.CreateRecordingError);
                }
                catch (RestRepositoryException)
                {
                    _logger.Error(Error.ReplayApiNotRespondingError);
                    MessageBox.Show(Error.ReplayApiNotRespondingError);
                }
                catch (OperationCanceledException)
                {
                    _logger.Warn(Warn.OperationCancelledWarn);
                    Invoke(new Action(() => _labelAdditionalInfo.Text = Info.CancelInfo));
                    BringControlsToDefaultState();
                }
                catch (LeagueOfLegendsProcessException)
                {
                    CloseLauncher = true;
                    TerminateLeagueProcessIfRunning();
                    _logger.Error(Error.LeagueClientNotRespondingError);
                    MessageBox.Show(Error.LeagueClientNotRespondingError);
                }
                catch (Exception)
                {
                    _logger.Error(Error.UnhandledExceptionError);
                    Invoke(new Action(() => _labelAdditionalInfo.Text = Error.UnhandledExceptionError));
                }
                finally
                {
                    _logger.Info(Info.CleaningDataInfo);
                    BringControlsToDefaultState();
                    await _unprocessedFilesMonitor.CheckForUnprocessedFilesAsync(_textBoxRecordingSavePath.Text);
                }
            }, cancelToken);
        }

        //CancelButton
        private void _buttonCancel_Click(object sender, EventArgs e)
        {
            var cancelInProgressText = $"Cancellation requested. Managing started tasks up to the state ready for cancel. Please wait...{Environment.NewLine}If the launcher has already started, don't close it manually or it will take much more time to reset.";
            _logger.Warn(cancelInProgressText);
            Invoke(new Action(() =>

            {
                _buttonCancel.Enabled = false;
                _buttonCancel.Text = CancellingText;
                _labelAdditionalInfo.Text = cancelInProgressText;
            }));
            _recordingCancellationManager.CancelCurrentToken();
        }

        //Form closure
        private void LolAutoRecorder_FormClosed(object sender, FormClosedEventArgs e)
        {
            _logger.Info(Info.AppClosedInfo);
            CloseLauncher = true;
            TerminateLeagueProcessIfRunning();
        }

        //Choose client executable button
        private void _buttonChooseClientExecutablePath_Click(object sender, EventArgs e)
        {
            _DialogOpenFile = new OpenFileDialog
            {
                Filter = ExecutableFilesFilterText,
                Title = ExecutableFilesText,
                InitialDirectory = _textBoxLeagueClientDirectoryPath.Text.Replace("/", "\\")
            };

            if (_DialogOpenFile.ShowDialog() == DialogResult.OK)
            {
                _logger.Info($"LoL client executable path updated: {_DialogOpenFile.FileName}");
                _textBoxLeagueClientDirectoryPath.Text = _DialogOpenFile.FileName;
                //todo: save path in configuration
            }
        }

        //Choose ROFL file button
        private void _buttonChooseRoflFilePath_Click(object sender, EventArgs e)
        {
            _DialogOpenFile = new OpenFileDialog
            {
                Filter = RoflFilesFilterText,
                Title = RoflFilesText,
                InitialDirectory = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments), "League of Legends\\Replays")
            };

            if (_DialogOpenFile.ShowDialog() == DialogResult.OK) _textBoxRoflFilePath.Text = _DialogOpenFile.FileName;
        }

        //Chose metadata file button
        private void _buttonChooseRecordingMetadataPath_Click(object sender, EventArgs e)
        {
            _DialogOpenFile = new OpenFileDialog
            {
                Filter = JsonFilesFilterText,
                Title = JsonFilesText,
                InitialDirectory = KnownFolders.GetPath(KnownFolder.Downloads)
            };

            if (_DialogOpenFile.ShowDialog() == DialogResult.OK) _textBoxRecordingMetadataPath.Text = _DialogOpenFile.FileName;
        }

        //Choose LeagueClient folder path
        private void _buttonChoseClientPath_Click(object sender, EventArgs e)
        {
            using (var folderBrowserDialog = new CommonOpenFileDialog
            {
                IsFolderPicker = true,
                InitialDirectory = _textBoxLeagueClientDirectoryPath.Text.Replace("/", "\\")
            })
            {
                if (folderBrowserDialog.ShowDialog() == CommonFileDialogResult.Ok && !string.IsNullOrWhiteSpace(folderBrowserDialog.FileName))
                {
                    _logger.Info($"LoL client base folder path updated: {folderBrowserDialog.FileName}");
                    _textBoxLeagueClientDirectoryPath.Text = folderBrowserDialog.FileName;
                    //todo: save path in configuration
                }
            }
        }

        //Choose Recording SavePath
        private void _buttonChooseRecordingSavePath_Click(object sender, EventArgs e)
        {
            using (var folderBrowserDialog = new CommonOpenFileDialog
            {
                IsFolderPicker = true,
                InitialDirectory = _textBoxRecordingSavePath.Text.Replace("/", "\\")
            })
            {
                if (folderBrowserDialog.ShowDialog() == CommonFileDialogResult.Ok && !string.IsNullOrWhiteSpace(folderBrowserDialog.FileName))
                {
                    _logger.Info($"Recording save path updated: {folderBrowserDialog.FileName}");
                    _textBoxRecordingSavePath.Text = folderBrowserDialog.FileName;
                    //todo: save path in configuration
                }
            }
        }

        private void LockOrUnlockTextBoxInputs(bool isReadOnly)
        {
            Invoke(new Action(() =>
            {
                _textBoxLeagueClientDirectoryPath.ReadOnly = isReadOnly;
                _textBoxClientExecutableName.ReadOnly = isReadOnly;
                _textBoxRoflFilePath.ReadOnly = isReadOnly;
                _textBoxRecordingMetadataPath.ReadOnly = isReadOnly;
                _textBoxRecordingSavePath.ReadOnly = isReadOnly;
            }));
        }

        private void BringControlsToDefaultState()
        {
            Invoke(new Action(() =>
            {
                _labelRecordingStatusInfo.Text = WaitingForInputText;
                _circularProgressBar1.Visible = false;
                _circularProgressBar1.Value = 0;
                _buttonRecord.Enabled = true;
                _buttonCancel.Enabled = false;
                _comboBoxScreenMode.Enabled = true;
                _buttonCancel.Text = CancelText;
            }));
            LockOrUnlockTextBoxInputs(isReadOnly: false);
            TerminateLeagueProcessIfRunning();
        }

        private void CheckForExecutionCancelRequest(CancellationToken cancellationToken)
        {
            if (cancellationToken.IsCancellationRequested)
            {
                _logger.Warn(Warn.CancellationRequestedWarn);
                cancellationToken.ThrowIfCancellationRequested();
            }
        }

        private bool IsLeagueProcessAlreadyRunning()
        {
            return Process.GetProcessesByName(LeagueClientProcessNameText)?.FirstOrDefault() != null;
        }

        private void TerminateLeagueProcessIfRunning()
        {
            if (CloseLauncher)
            {
                _logger.Info(Info.TerminatingClientInfo);
                Process process = null;
                do
                {
                    try
                    {
                        process = Process.GetProcessesByName(LeagueClientProcessNameText)?.FirstOrDefault();
                        process?.Kill();
                    }
                    catch (Win32Exception)
                    {
                        //just ignore, the process is probably terminating already
                    }

                } while (process != null);
            }
        }
    }
}
